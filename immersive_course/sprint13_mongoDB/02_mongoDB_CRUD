mongoDB 도큐먼트는 모두 고유한 _id값을 가지고 있어야 한다

이 _id필드값은 각 도큐먼트를 구별하는 역할을 한다

도큐먼트 내 필드와 값이 똑같더라도 _id값이 다르면 서로 다른 도큐먼트로 간주한다

반면에 도큐먼트내 필드와 값이 다르더라더 _id값이 같으면 서로 같은 도큐먼트로 여겨 에러가 발생하기도 한다

도큐먼트를 추가할때  _id필드와 값을 특정하지 않는다면 자동으로 생성된다

create

insert를 이용하여 도큐먼트에 삽입하기 위해 insert()의 괄호안에 삽입하고자 하는 도큐먼트를 작성한다

삽입시 duplicated key를 주의해야한다.

이미 같은 _id값을 가지는 도큐먼트가 컬렉션 내부에 존재하는지를 확인해야한다,

_id를 입력하지 않는다면 기본 값으로 objectID를 생성하여 할당한다.

한번에 다수의 도큐먼트를 삽입하기 위해서 배열안에 해당하는 도큐먼트를 담아주어야 한다.

insert명령어를 사용하면 주어진 도큐먼트 배열의 인덱스 순서로 작업이 실행된다.

그러나 ordered를 추가하면 순서에 상광벗이 고유한 _id를 가진 도큐먼트는 모두 컬렉션에 삽입된다.

만약 사용자가 존재하지 않는 컬렉션에 도큐먼트를 넣는 경우 그와 동시에 컬렉션이 만들어 지게 된다.

read

use db와 show collections 라는 명령어를 이용해 사용하기 원하는 데이터베이스를 사용하고 확인해 볼 수 있다.

db.collection_name.find(<쿼리문>) 

위 명령어 사용시 이미 필요한 데이터베이스 공간으로 이동했기에 사용할 데이터베이스의 이름을 특정해서 작성하 ㄹ필요는 없다

find에 따른 실제 결과물은 훨씬 많을수도 있지만 화면에는 랜덤하게 총 20개의 결과물만 출력된다.

조건을 추가적으로 작성하고자 할땐 find(<쿼리문1, 쿼리문2)의 방식으로 작성할 수 있다

쿼리문을 작성하지 않으면 모든 데이터를 조회한다

pretty()를 사용하면 출력물의 가독성이 상승한다

count()를 사용하면 데이터의 수를 알 수 있다

특정 결과물 하나만을 원하면 findOne()을 사용할 수 있다. 고유값인 _id가 필요하다

update

updateOne은 주어진 기준에 맞는 다수의 도큐먼트 중 첫번째 도큐먼트 하나만 업데이트한다

updateMany는 쿼리문과 일치하는 모든 도큐먼트를 업데이트한다

db.collection_name.updateMany(<쿼리문>, <수정사항>)

첫번째 인자에는 어떤 항목을 업데이트할것인지 조건을 적는 쿼리문이 인자로 들어온다

두번째 인자는 발생할 업데이트 내용을 특정한다

delete

deleteOne은 주어진 기준에 맞는 도큐먼트중 첫번째 도큐먼트를 삭제한다

deleteMany는 쿼리문과 일치하는 모든 도큐먼트를 삭제한다

delete는 업데이트와 방식이 비슷하다

컬렉션을 샂게하기위해서는 drop이라는 명령어가 필요하다

db.collection_name.drop()



