ReactëŠ” ì»´í¬ë„ŒíŠ¸ íŠ¸ë¦¬ ì„ ì–¸ê³¼ props ì‚¬ìš©ì„ í†µí•´ì„œ, DOM ë…¸ë“œì— ë ˆí¼ëŸ°ìŠ¤ë¥¼ ê±¸ì§€ ì•Šê³ ë„ UI ì œì–´ê°€ ëŒ€ë¶€ë¶„ ê°€ëŠ¥í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ê°œë°œ ì¤‘ì—ëŠ” íŠ¹ì • ë…¸ë“œì— ë ˆí¼ëŸ°ìŠ¤ë¥¼ ê±¸ê³  ì ‘ê·¼í•´ì•¼í•  ê²½ìš°ë„ ê°€ë”ì”© ìˆìŠµë‹ˆë‹¤.
React RefëŠ” íŠ¹ì •í•œ DOM ë…¸ë“œ, í˜¹ì€ ì»´í¬ë„ŒíŠ¸ ì¸ìŠ¤í„´ìŠ¤ì— referenceë¥¼ ê±¸ì–´ì£¼ëŠ” ê²ƒì…ë‹ˆë‹¤. Refë¥¼ í†µí•´ì„œ render ë©”ì„œë“œì—ì„œ ë§Œë“  DOM ë…¸ë“œë‚˜ React ìš”ì†Œì— ì ‘ê·¼í•´ì„œ, ê°’ì„ ì–»ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì´ ê¸€ì˜ ë‚´ìš©ì€ React v.16.7ë¡œ í”„ë¡œì íŠ¸ë¥¼ í•˜ëŠ” ë™ì•ˆ ì œê°€ ref ë¥¼ ì‚¬ìš©í•˜ê¸°ìœ„í•´ ì•Œì•„ì•¼ë§Œ í–ˆë˜ ë‚´ìš©ë“¤ì„ ëª¨ì€ ê²ƒì…ë‹ˆë‹¤. ì—¬ê¸° ë‚˜ì˜¤ëŠ” ì†ŒìŠ¤ë“¤ì€ ref ë¥¼ ì‚¬ìš©í•œê²ƒì„ ì¬êµ¬ì„±í–ˆìŠµë‹ˆë‹¤.

Ref ë§Œë“¤ê¸°
class Domain extends Component {  sideBarResizeHandleRef = React.createRef();  render() {    return (      <SideBarResize className="side-bar" ref={this.sideBarResizeHandleRef} >        {/* ... */}      </SideBarResize>    );  }}
í´ë˜ìŠ¤ì— ref ë¥¼ í• ë‹¹í•  ë³€ìˆ˜ë¥¼ ë§Œë“¤ì–´ë‘ê³  createRef() ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. render ì—ì„œ ìš”ì†Œì— ì°¸ì¡°ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤ ( ref={this.sideBarResizeHandleRef} ).

Refì— ì ‘ê·¼í•˜ê¸°
ìš”ì†Œì— ref ë¥¼ ì „ë‹¬í–ˆìœ¼ë‹ˆ ì´ì œ ë³€ìˆ˜ë¥¼ í†µí•´ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì°¸ì¡°í•œ ìš”ì†Œì˜ ê°’ì„ ì–»ê±°ë‚˜, ìˆ˜ì •í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•˜ë©°, ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
componentDidMount() {  this.sideBarResizeHandleRef.current.onResize();}
ref ê°€ ì°¸ì¡°í•˜ëŠ” ì¸ìŠ¤í„´ìŠ¤ì˜ onResize ë©”ì†Œë“œë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. ìš°ë¦¬ê°€ ì„¤ì •í•œ ìš”ì†ŒëŠ” ref ì˜ current ì†ì„±ì— ë‹´ê¸°ê²Œ ë©ë‹ˆë‹¤.

Refì˜ ê°’
ë…¸ë“œì˜ íƒ€ì…ì— ë”°ë¼ ref ì˜ ê°’ì´ ë‹¤ë¦…ë‹ˆë‹¤.
Reactì˜ ref ë¬¸ì„œ ì— ë”°ë¥´ë©´ ë‹¤ìŒ ë‘ê°œì˜ ì¼€ì´ìŠ¤ê°€ ìˆìŠµë‹ˆë‹¤:
HTML ìš”ì†Œì— ref ì–´íŠ¸ë¦¬ë·°íŠ¸ë¥¼ ì „ë‹¬í•˜ë©´, DOM ë…¸ë“œê°€ current ì†ì„±ê°’ì´ ë©ë‹ˆë‹¤.
ë¦¬ì•¡íŠ¸ ìš”ì†Œì¸ ì»¤ìŠ¤í…€ í´ë˜ìŠ¤ ì»´í¬ë„ŒíŠ¸ì— ref ì–´íŠ¸ë¦¬ë·°íŠ¸ë¥¼ ì“°ë©´, ë§ˆìš´íŠ¸ëœ ì»´í¬ë„ŒíŠ¸ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ current ì†ì„±ê°’ì´ ë©ë‹ˆë‹¤.
ë˜í•œ í•¨ìˆ˜ ì»´í¬ë„ŒíŠ¸ëŠ” ì¸ìŠ¤í„´ìŠ¤ê°€ ì—†ê¸° ë•Œë¬¸ì— ref ë¥¼ ì¤„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í•¨ìˆ˜ ì»´í¬ë„ŒíŠ¸ì— ref ë¥¼ ì „ë‹¬í•˜ë©´ ê·¸ ref ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìœ¼ë©°, development ëª¨ë“œì—ì„œ ë‹¤ìŒê³¼ ê°™ì€ ë©”ì‹œì§€ê°€ ì½˜ì†”ì— í‘œì¶œë©ë‹ˆë‹¤. index.js:1446 Warning: Function components cannot be given refs. Attempts to access this ref will fail.


Refë¥¼ ì–¸ì œ ì“¸ê¹Œ?
React ë¬¸ì„œ ì— ë”°ë¥´ë©´, ref ë¥¼ ì“°ëŠ” ê²½ìš°ëŠ”:
DOM ë…¸ë“œì— ì ‘ê·¼í•´ì„œ í¬ì»¤ìŠ¤, ë¯¸ë””ì–´ ì¬ìƒ ë“±ì„ ì œì–´í•˜ê±°ë‚˜, ì‚¬ì´ì¦ˆë¥¼ ì–»ì–´ì˜¬ ë•Œ
ì• ë‹ˆë©”ì´ì…˜ì„ ì§ì ‘ ì‹¤í–‰ì‹œí‚¬ ë•Œ
ì„œë“œ íŒŒí‹° ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•  ë•Œ
ì¶”ê°€ì ìœ¼ë¡œ ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš°ì—ë„ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ìì‹ì˜ stateì— ë¶€ëª¨ê°€ ì ‘ê·¼í•  ë•Œ
Stateë¡œ ì œì–´í•˜ì§€ ì•ŠëŠ” ë¹„ì œì–´ ì»´í¬ë„ŒíŠ¸ ë¥¼ ì‚¬ìš©í•  ë•Œ


class FilterBar extends Component {  inputRef = createRef;  handleClear = () => {    this.inputRef.current.value = ''; // clear the input    const someState = {};    this.setState(      someState,      () => {        this.inputRef.current.focus(); // focus the input      }    );  };  render() {    return (      <>        <input ref={this.inputRef} type="text" />        {/* ... */}      </>    );  }}
<input /> ì— ref ë¥¼ ìƒì„±í•˜ê³ , handleClear í•¸ë“¤ëŸ¬ê°€ input ì— í¬ì»¤ìŠ¤ë¥¼ ì¤ë‹ˆë‹¤ . ê·¸ë¦¬ê³  current ëŠ” <input /> ìš”ì†Œì´ë¯€ë¡œ, inputRef.current.value ë¡œ ê°’ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


class Layout extends Component {  contentsScrollbar = createRef();  componentDidUpdate() {    const { current } = this.contentsScrollbar;    if (current) {      current.update(); // update    }  }  render() {    return (      <div className="wrap">        <Header />        <div className="container">          <Scrollbars ref={this.contentsScrollbar}>            {this.props.children}          </Scrollbars>        </div>      </div>    );  }}
í—¤ë”ì™€ ì»¨í…ì¸ ë¡œ êµ¬ì„±ë˜ëŠ” Layout ì´ ì„œë“œ íŒŒí‹° ë¼ì´ë¸ŒëŸ¬ë¦¬ Scorollbars ì˜ ë‚´ë¶€ì— ì»¨í…ì¸ ë¥¼ ë‹´ê³ ì„œ, ref ë¥¼ ì „ë‹¬í•˜ê³ , Scrollbars ëª¨ë“ˆì´ ì œê³µí•˜ëŠ” API update() ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.


class ServerRegister extends Component {  this.content = createRef();  handleConfirm = () => {    const { selects: ids } = this.content.current.state;    // post the data  };  render() {    return (      <>        <Dialog>          <Content ref={this.content} serverId={this.props.serverId} />        </Dialog>        {this.state.closeRedirect}      </>    );  }}
ì¼ë°˜ì ìœ¼ë¡œëŠ” ë¶€ëª¨ê°€ ìì‹ì˜ ìƒíƒœ(state)ì— ì ‘ê·¼í•  ë¹ˆë„ëŠ” ë‚®ìŠµë‹ˆë‹¤. ìì‹ì˜ ë³€í™”ë¥¼ ì½œë°± í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ë¶€ëª¨ê°€ ê¸°ë¡í•˜ê³ (ê°€ì§€ê³ ), ìì‹ì—ê²ŒëŠ” ë³€í™”í•˜ëŠ” ìƒíƒœë¥¼ ë‚´ë ¤ì£¼ë©´ ë˜ë‹ˆê¹Œ ìš”.
ìœ„ëŠ” ê·¸ë ‡ê²Œ í•˜ì§€ ì•Šì€ ê²½ìš°ì…ë‹ˆë‹¤. ìì‹ ìš”ì†Œ Content ì˜ state ë¥¼ handleConfirm í•¸ë“¤ëŸ¬ê°€ ref ë¡œ ì—­ì°¸ì¡°í•´ì„œ ë°ì´í„°ë¥¼ postí•©ë‹ˆë‹¤.

ì—¬ê¸°ì— í•´ë‹¹í•˜ëŠ” ê²½ìš°ë¡œëŠ”, ë¶€ëª¨ì˜ ë Œë” íŠ¸ë¦¬ê°€ ëŒ€ê·œëª¨ë¼ì„œ ë Œë” ë¹„ìš©ì´ ë†’ê³ , ìì‹ ì»´í¬ë„ŒíŠ¸ëŠ” number input tagì¸ ê²½ìš°ê°€ ìˆì—ˆìŠµë‹ˆë‹¤. ì¸í’‹ì— onChange ë¡œ setState ë¥¼ ê±¸ì–´ë†“ì•˜ì„ ê²½ìš°, ìˆ«ì íƒ€ì… ì¸í’‹ì€ í™”ì‚´í‘œí‚¤ë¥¼ ê¾¹ ëˆ„ë¥´ë©´ ì—°ì†ì ìœ¼ë¡œ ìƒíƒœ ë³€í™”ë¥¼ ì¼ìœ¼í‚¤ê¸° ë•Œë¬¸ì—, ì´ ìƒíƒœë³€í™”ì— ë”°ë¼ ë¶€ëª¨ë¥¼ ë‹¤ì‹œ ë Œë”ë§í•˜ë©´ ë ‰ì´ ìœ ë°œë˜ì—ˆìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ ì¸í’‹ì„ ê°€ì§„ ìì‹ ì»´í¬ë„ŒíŠ¸ì— ref ë¥¼ ì£¼ê³ , í•„ìš”í•  ë•Œì—ë§Œ ìì‹ì˜ ìƒíƒœì— ì ‘ê·¼í•˜ë„ë¡ ë°”ê¿¨ìŠµë‹ˆë‹¤.

ë˜í•œ ì´ëŸ´ ë•Œì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ëŒ€ì•ˆì ì¸ ë°©ë²•ì´ ìˆëŠ”ë°, ë‹¤ìŒì˜ ì˜ˆì‹œë¥¼ ë³´ê² ìŠµë‹ˆë‹¤.
class NameForm extends React.Component {  input = React.createRef();  handleSubmit = event => {    alert('A name was submitted: ' + this.input.current.value);    event.preventDefault();  }  render() {    return (      <form onSubmit={this.handleSubmit}>        <label>          Name: <input type="text" ref={this.input} />        </label>        <input type="submit" value="Submit" />      </form>    );  }}
ìœ„ ì½”ë“œëŠ” ìƒíƒœë¥¼ ì œì–´í•˜ì§€ ì•ŠëŠ” ë¹„ì œì–´ ì»´í¬ë„ŒíŠ¸ ( uncontrolled component )ì…ë‹ˆë‹¤. DOM ë…¸ë“œì— ref ë¥¼ ì£¼ê³ ì„œ í¼ ê°’ì„ ê°€ì ¸ì˜¤ë©°, ìƒíƒœ ì—…ë°ì´íŠ¸ì— ëŒ€í•œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë¥¼ ì‘ì„±í•˜ì§€ ì•Šê³  DOMì´ í¼ ë°ì´í„°ë¥¼ ë‹¤ë£¨ë„ë¡ í•©ë‹ˆë‹¤.
ìƒíƒœë¥¼ ê´€ë¦¬í•˜ëŠ”ë° ìˆì–´ì„œ ì‚¬ìš©ìì˜ ì…ë ¥ê°’ì„ ìƒíƒœë¡œ ê´€ë¦¬í•˜ê³  í¼ì˜ ê°’ì„ ì œì–´í•˜ëŠ” ë°©ë²•ì´ ì¼ë°˜ì ì…ë‹ˆë‹¤. ë¹„ì œì–´ ì»´í¬ë„ŒíŠ¸ëŠ” ëŒ€ì•ˆì ì¸ ë°©ë²•ì´ë©° ê°„í¸í•˜ê²Œ ì ì€ ì½”ë“œë¡œ ì‘ì„±í•  ìˆ˜ ìˆëŠ”ê²Œ ì¥ì •ì…ë‹ˆë‹¤. ì¼ë°˜ì ì¸ ìƒí™©ì—ì„œëŠ” stateë¡œ ì œì–´í•´ì•¼ í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ React ë©”ì¸ ì»¨íŠ¸ë¦¬ë·°í„° Dan Abramovë„ ë•Œì— ë”°ë¼ì„œ ëŠ” ì´ ë°©ë²•ì„ ì„ í˜¸í•œë‹¤ê³  í•˜ë‹ˆ ì ì ˆí•˜ê²Œ ì“°ë©´ ë˜ê² ìŠµë‹ˆë‹¤.
ì €ëŠ” ì¢…ì¢… ì‚¬ìš©í•©ë‹ˆë‹¤. ë”°ë¡œ ì¼ì¼íˆ stateë¥¼ ì»¨íŠ¸ë¡¤í•˜ì§€ ì•Šì•„ë„ ë˜ë‹ˆ ì¢‹ìŠµë‹ˆë‹¤.


class FileInput extends React.Component {  this.fileInputRef = createRef();  handleSubmit = e => {    e.preventDefault();    alert(      `Selected file - ${        this.fileInputRef.current.files[0].name      }`    );  }  render() {    return (      <form onSubmit={this.handleSubmit}>        <label>          Upload file: <input type="file" ref={this.fileInputRef} />        </label>        <br />        <button type="submit">Submit</button>      </form>    );  }}ReactDOM.render(  <FileInput />,  document.getElementById('root'));
Reactì—ì„œ <input type="file" /> ì€ í•­ìƒ ë¹„ì œì–´ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤. íŒŒì¼ê³¼ ìƒí˜¸ì‘ìš©í•˜ë ¤ë©´ File APIë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ref ë¥¼ ì „ë‹¬í•˜ê³ ì„œ í•¸ë“¤ëŸ¬ì—ì„œ íŒŒì¼ì— ì ‘ê·¼í•©ë‹ˆë‹¤.

ê¸°ë²•: ref ì „ë‹¬í•˜ê¸°
ì§ì ‘ì ì¸ ë¶€ëª¨-ìì‹ê°„ì´ ì•„ë‹Œ, ref ë¥¼ ìì‹ì—ê²Œ ì „ë‹¬í•´ ìì‹ì˜ ìš”ì†Œë¥¼ ë¶€ëª¨ê°€ ì°¸ì¡°í•˜ëŠ” í…Œí¬ë‹‰ì…ë‹ˆë‹¤.
const FancyButton = React.forwardRef((props, ref) => (  <button ref={ref} className="FancyButton">    {props.children}  </button>));// You can now get a ref directly to the DOM button:const ref = React.createRef();<FancyButton ref={ref}>Click me!</FancyButton>;
React.forwardRef API ë¥¼ ì‚¬ìš©í–ˆê³ , FancyButton ì€ React.forwardRef ë¡œ ê°ì‹¸ì ¸ì„œ ì •ì˜ë˜ì—ˆìŠµë‹ˆë‹¤. FancyButton ì— ref ë¥¼ ì£¼ë©´, ì•ˆìª½ì— ìˆëŠ” ë²„íŠ¼ì´ ì°¸ì¡°ë¥¼ ë°›ê²Œ ë©ë‹ˆë‹¤. ì—¬ê¸°ì—ì„œ FancyButton ì„ React.forwardRef ë¡œ ê°ì‹¸ì§€ ì•ŠëŠ”ë‹¤ë©´, FancyButton ìì²´ì— ì°¸ì¡°ê°€ ê±¸ë¦½ë‹ˆë‹¤.

ê·¸ëŸ´ë§Œí•œ ì´ìœ ê°€ ì—†ê¸´ í•˜ì§€ë§Œ forwardRef ë¥¼ ì§ì ‘ êµ¬í˜„í•˜ê³  ì‹¶ë‹¤ë©´, ê³ ì°¨ ì»´í¬ë„ŒíŠ¸ë¡œ ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë§Œë“  ì»´í¬ë„ŒíŠ¸ëŠ” ref ì†ì„±ì„ ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ë°›ìœ¼ë©°, ì•ˆìª½ìœ¼ë¡œ ì „ë‹¬í•´ì£¼ë©´ ê·¸ë§Œì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ref ë¼ëŠ” ì´ë¦„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤ëŠ” forwardRef ì˜ ì¥ì ì„ ìƒì–´ë²„ë¦¬ê¸° ë©ë‹ˆë‹¤. ì‚¬ìš© ì¤‘ í—·ê°ˆë¦´ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

ì•ì—ì„œ ë´¤ë“¯ì´ ê³ ì°¨ ì»´í¬ë„ŒíŠ¸ë¥¼ ì‚¬ìš©í•  ë•Œ ë°”ê¹¥ ì»´í¬ë„ŒíŠ¸ì— ref ë¥¼ ì¤€ë‹¤ê³  ì•ˆìª½ìœ¼ë¡œ ì „ë‹¬ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¹„ìŠ·í•˜ê²Œ React-Reduxë¥¼ ì¨ì„œ ìŠ¤í† ì–´ì— ì—°ê²°ëœ ì»´í¬ë„ŒíŠ¸ì—ì„œë„ ref ì‚¬ìš©ì‹œ ë‹¤ë¥¸ ë¬´ì–¸ê°€ê°€ í•„ìš”í•©ë‹ˆë‹¤.
export default connect(  null,  null,  null,  { forwardRef: true })(App);
ê·¸ ë‹µì€ connect ì˜ options ì¸ìì— { forwardRef: true } ë¥¼ ì „ë‹¬ í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. connect ëœ ì»´í¬ë„ŒíŠ¸ì— ref ë¥¼ ì „ë‹¬í•˜ë©´ ì‹¤ì œ ì»´í¬ë„ŒíŠ¸ ì¸ìŠ¤í„´ìŠ¤ì— ref ê°€ ì¶”ê°€ë©ë‹ˆë‹¤.

ìì‹ ì»´í¬ë„ŒíŠ¸ì˜ DOM ë…¸ë“œì— ì ‘ê·¼í•˜ëŠ” ê²ƒì€ ì»´í¬ë„ŒíŠ¸ì˜ ìº¡ìŠí™”ë¥¼ íŒŒê´´í•˜ê¸° ë–„ë¬¸ì— ê¶Œì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê·¸ë ‡ì§€ë§Œ ê°€ë”ê°€ë‹¤ ìì‹ ì»´í¬ë„ŒíŠ¸ì˜ DOM ë…¸ë“œë¥¼ í¬ì»¤ìŠ¤í•˜ëŠ” ì¼ì´ë‚˜, í¬ê¸° ë˜ëŠ” ìœ„ì¹˜ë¥¼ ê³„ì‚°í•˜ëŠ” ì¼ ë“±ì„ í•  ë•Œì—ëŠ” íš¨ê³¼ì ì¸ ë°©ë²•ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ref
ì´ ê¸€ì—ì„œëŠ” createRef ê°€ ì½”ë“œ ì˜ˆë¬¸ì— ì“°ì˜€ìŠµë‹ˆë‹¤. ì´ê²ƒ ë§ê³ ë„ ref ë¥¼ ì„¤ì •í•˜ëŠ” ë°©ë²•ì—” ì´ 2ê°€ì§€ê°€ ìˆìŠµë‹ˆë‹¤.
React.createRef() API
ì½œë°± ref
ë¬¸ìì—´ ref
í•˜ì§€ë§Œ ë¬¸ìì—´ refëŠ” ì‚¬ìš©í•˜ì§€ ì•Šì•„ì•¼í•©ë‹ˆë‹¤. ìœ„ ë‘ê°œë§Œ ì¨ì•¼ í•©ë‹ˆë‹¤.
1. React.createRef() API
ì´ ê¸€ì—ì„œ ì“´ ê·¸ APIì…ë‹ˆë‹¤. ë‹¤ìŒìœ¼ë¡œ ë³¼ ì½œë°± refì— ë¹„í•´ì„œ, createRef ëŠ” ë”°ë¡œ ì½œë°±ì„ ë§Œë“¤ì§€ ì•Šì•„ ì½”ë“œê°€ ê°„ë‹¨í•´ì§€ëŠ” ì¥ì ì´ ìˆìŠµë‹ˆë‹¤.

2. ì½œë°± ref
ì´ ê¸€ì—ì„œ ì‚¬ìš©í•œ ë°©ë²•ì…ë‹ˆë‹¤. ref ë¥¼ ì„¤ì •í•˜ê³  í•´ì œí•˜ëŠ” ìƒí™©ì„ ì„¸ì„¸í•˜ê²Œ ë‹¤ë£° ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì½œë°± refë¥¼ ì‚¬ìš©í•  ë•Œì—ëŠ” ref ì–´íŠ¸ë¦¬ë·°íŠ¸ì— React.createRef() ë¥¼ í†µí•´ ìƒì„±ëœ ref ë¥¼ ì „ë‹¬í•˜ëŠ” ëŒ€ì‹ , í•¨ìˆ˜ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤. ì „ë‹¬ëœ í•¨ìˆ˜ëŠ” ë‹¤ë¥¸ ê³³ì— ì €ì¥ë˜ê³  ì ‘ê·¼ë  ìˆ˜ ìˆëŠ” React ìš”ì†Œë‚˜ DOM ë…¸ë“œë¥¼ ì¸ìë¡œì„œ ë°›ìŠµë‹ˆë‹¤.


ë¨¼ì € í”í•œ ìœ ì¦ˆì¼€ì´ìŠ¤ì…ë‹ˆë‹¤ .

class CustomTextInput extends React.Component {  constructor(props) {    super(props);    this.textInput = null;    this.setTextInputRef = element => {      this.textInput = element;    };    this.focusTextInput = () => {      // DOM APIë¥¼ ì‚¬ìš©í•˜ì—¬ text íƒ€ì…ì˜ input ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ í¬ì»¤ìŠ¤í•©ë‹ˆë‹¤.      if (this.textInput) this.textInput.focus();    };  }  componentDidMount() {    // ë§ˆìš´íŠ¸ ë˜ì—ˆì„ ë•Œ ìë™ìœ¼ë¡œ text íƒ€ì…ì˜ input ì—˜ë¦¬ë¨¼íŠ¸ë¥¼ í¬ì»¤ìŠ¤í•©ë‹ˆë‹¤.    this.focusTextInput();  }  render() {    // text íƒ€ì…ì˜ input ì—˜ë¦¬ë¨¼íŠ¸ì˜ ì°¸ì¡°ë¥¼ ì¸ìŠ¤í„´ìŠ¤ì˜ í”„ë¡œí¼í‹°    // (ì˜ˆë¥¼ ë“¤ì–´`this.textInput`)ì— ì €ì¥í•˜ê¸° ìœ„í•´ `ref` ì½œë°±ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.    return (      <div>        <input          type="text"          ref={this.setTextInputRef}        />        <input          type="button"          value="Focus the text input"          onClick={this.focusTextInput}        />      </div>    );  }}
ì»´í¬ë„ŒíŠ¸ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ ë§ˆìš´íŠ¸ ë  ë•Œ ReactëŠ” ref ì½œë°±ì„ DOM ì—˜ë¦¬ë¨¼íŠ¸ì™€ í•¨ê»˜ í˜¸ì¶œí•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì»´í¬ë„ŒíŠ¸ì˜ ì¸ìŠ¤í„´ìŠ¤ì˜ ë§ˆìš´íŠ¸ê°€ í•´ì œë  ë•Œ, ref ì½œë°±ì„ null ê³¼ í•¨ê»˜ í˜¸ì¶œí•©ë‹ˆë‹¤. ref ì½œë°±ë“¤ì€ componentDidMount ë˜ëŠ” componentDidUpdate ê°€ í˜¸ì¶œë˜ê¸° ì „ì— í˜¸ì¶œë©ë‹ˆë‹¤.



ref => {
  this.contents[key] = ref;
}
ê°ê°ì˜ content ëŠ” key ë¥¼ ê°€ì§€ê³  ìˆê³  content ë§ˆë‹¤ ref ë¥¼ ì„¤ì •í•˜ë ¤ê³  í•©ë‹ˆë‹¤. content ê°€ dictionary ë˜ëŠ” array í˜•ì‹ìœ¼ë¡œ ì˜¨ë‹¤ë©´ ë°˜ë³µë¬¸ì„ ì‚¬ìš©í•´ì„œ ì²˜ë¦¬í•˜ê² ì£ . createRef() ë¡œëŠ” ì²˜ë¦¬í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤. ì½œë°± refë¥¼ ì¨ì„œ ê° content ë³„ë¡œ ref ë¥¼ ì„¤ì •í•˜ê³  key ë¥¼ í†µí•´ ì„¤ì •í•œ ref ì— ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ í–ˆìŠµë‹ˆë‹¤.


3. ë¬¸ìì—´ ref
ReactëŠ” ë¬¸ìì—´ refê°€ ë ˆê±°ì‹œ APIì´ë©°, ì‚¬ìš©ì„ ì§€ì–‘í•˜ê³  ì½œë°±ì´ë‚˜ createRef APIë¡œ ë°”ê¿”ì„œ ì“°ë¼ê³  ê¶Œì¥ í•©ë‹ˆë‹¤.


ì½œë°± ref ì»¨ë²¤ì…˜
ì½œë°± refë¥¼ ì“¸ ë•Œ ì£¼ë¡œ ë‹¤ìŒê³¼ ê°™ì€ ì»¨ë²¤ì…˜ìœ¼ë¡œ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.

class Monitoring extends Component {

  sideBarResizeHandleRef = null;

  // ...
}
ë©¤ë²„ ë³€ìˆ˜ë¡œ ref ë³€ìˆ˜ë¥¼ ì„ ì–¸í•´ì¤ë‹ˆë‹¤. Class field declarations ì„ ì‚¬ìš©í•œë‹¤ë©´ constructor ì˜ ë°”ê¹¥ì— ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.



setFileInputRef = element => {
  this.fileInputRef = element;
};

// ...or

refFileInput = ref => {
  this.fileInputRef = ref;
}
ì½œë°±ì„ í´ë˜ìŠ¤ í•¨ìˆ˜ë¡œ ì •ì˜í–ˆìŠµë‹ˆë‹¤.

<input type="file" ref={ref => (this.fileInputRef = ref)} />
ì½œë°±ì„ render() ì•ˆì—ì„œ ì¸ë¼ì¸ í•¨ìˆ˜ë¡œ ì„ ì–¸í•˜ëŠ”ê²ƒ ë˜í•œ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ì½œë°± refì— ëŒ€í•œ ì£¼ì˜ì‚¬í•­ : ì¸ë¼ì¸ í•¨ìˆ˜ë¡œ ì½œë°±ì„ ì„ ì–¸í–ˆë‹¤ë©´ ref ì½œë°±ì€ ì—…ë°ì´íŠ¸ ê³¼ì •ì—ì„œ í•œë²ˆì€ null ë¡œ, ê·¸ ë‹¤ìŒì—ëŠ” DOM ì—˜ë¦¬ë¨¼íŠ¸ë¡œ, ì´ ë‘ ë²ˆ í˜¸ì¶œë©ë‹ˆë‹¤. ì´ëŸ¬í•œ í˜„ìƒì€ ë§¤ ë Œë”ë§ë§ˆë‹¤ ref ì½œë°±ì˜ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë˜ë¯€ë¡œ Reactê°€ ì´ì „ì— ì‚¬ìš©ëœ ref ë¥¼ ì œê±°í•˜ê³  ìƒˆ ref ë¥¼ ì„¤ì •í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— ì¼ì–´ë‚©ë‹ˆë‹¤. ì´ëŸ¬í•œ í˜„ìƒì€ ref ì½œë°±ì„ í´ë˜ìŠ¤ì— ë°”ì¸ë”©ëœ ë©”ì„œë“œë¡œ ì„ ì–¸í•¨ìœ¼ë¡œì¨ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ë§ì€ ê²½ìš° ì´ëŸ¬í•œ í˜„ìƒì€ ë¬¸ì œê°€ ë˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì„ ê¸°ì–µí•˜ì„¸ìš”.


ref ì½œë°±ì„ í´ë˜ìŠ¤ í•¨ìˆ˜(ë©”ì„œë“œ)ë¡œ ì •ì˜í•˜ë©° ì‚¬ìš©í•˜ëŠ” ê²½ìš° í´ë˜ìŠ¤ ì½”ë“œê°€ ì¥í™©í•´ì§€ëŠ” ë¬¸ì œê°€ ìˆì—ˆìŠµë‹ˆë‹¤. ref ë¥¼ í•˜ë‚˜ ì„ ì–¸í•  ë•Œë§ˆë‹¤ ë³€ìˆ˜ ì´ˆê¸°í™”, ref ì½œë°±ì´ ì¶”ê°€ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ì´ëŸ° ì´ìœ ë¡œ createRef ì„ ë” ì„ í˜¸í•©ë‹ˆë‹¤.

useinview

react-intersection-observer
Version Badge GZipped size Test License Downloads

React implementation of the Intersection Observer API to tell you when an element enters or leaves the viewport. Contains both a Hooks, render props and plain children implementation.

Storybook Demo: https://react-intersection-observer.vercel.app

Features
ğŸ£ Hooks or Component API - With useInView it's easier than ever to monitor elements
âš¡ï¸ Optimized performance - Reuses Intersection Observer instances where possible
âš™ï¸ Matches native API - Intuitive to use
ğŸ§ª Ready to test - Mocks the Intersection Observer for easy testing with Jest
ğŸŒ³ Tree-shakeable - Only include the parts you use
ğŸ’¥ Tiny bundle ~1.7 kB gzipped
Installation
Install using Yarn:

yarn add react-intersection-observer
or NPM:

npm install react-intersection-observer --save
Usage
Hooks ğŸ£
useInView
// Use object destructing, so you don't need to remember the exact order
const { ref, inView, entry } = useInView(options);

// Or array destructing, making it easy to customize the field names
const [ref, inView, entry] = useInView(options);
React Hooks make it easy to monitor the inView state of your components. Call the useInView hook with the (optional) options you need. It will return an array containing a ref, the inView status and the current entry. Assign the ref to the DOM element you want to monitor, and the hook will report the status.

import React from 'react';
import { useInView } from 'react-intersection-observer';

const Component = () => {
  const { ref, inView, entry } = useInView({
    /* Optional options */
    threshold: 0,
  });

  return (
    <div ref={ref}>
      <h2>{`Header inside viewport ${inView}.`}</h2>
    </div>
  );
};
Edit useInView

Render props
To use the <InView> component, you pass it a function. It will be called whenever the state changes, with the new value of inView. In addition to the inView prop, children also receive a ref that should be set on the containing DOM element. This is the element that the IntersectionObserver will monitor.

If you need it, you can also access the IntersectionObserverEntry on entry, giving you access to all the details about the current intersection state.

import { InView } from 'react-intersection-observer';

const Component = () => (
  <InView>
    {({ inView, ref, entry }) => (
      <div ref={ref}>
        <h2>{`Header inside viewport ${inView}.`}</h2>
      </div>
    )}
  </InView>
);

export default Component;
Edit InView render props

Plain children
You can pass any element to the <InView />, and it will handle creating the wrapping DOM element. Add a handler to the onChange method, and control the state in your own component. Any extra props you add to <InView> will be passed to the HTML element, allowing you set the className, style, etc.

import { InView } from 'react-intersection-observer';

const Component = () => (
  <InView as="div" onChange={(inView, entry) => console.log('Inview:', inView)}>
    <h2>Plain children are always rendered. Use onChange to monitor state.</h2>
  </InView>
);

export default Component;
Edit InView plain children

âš ï¸ When rendering a plain child, make sure you keep your HTML output semantic. Change the as to match the context, and add a className to style the <InView />. The component does not support Ref Forwarding, so if you need a ref to the HTML element, use the Render Props version instead.

API
Options
Provide these as props on the <InView /> component or as the options argument for the hooks.

Name	Type	Default	Required	Description
root	Element	document	false	The IntersectionObserver interface's read-only root property identifies the Element or Document whose bounds are treated as the bounding box of the viewport for the element which is the observer's target. If the root is null, then the bounds of the actual document viewport are used.
rootMargin	string	'0px'	false	Margin around the root. Can have values similar to the CSS margin property, e.g. "10px 20px 30px 40px" (top, right, bottom, left).
threshold	number | number[]	0	false	Number between 0 and 1 indicating the percentage that should be visible before triggering. Can also be an array of numbers, to create multiple trigger points.
trackVisibility ğŸ§ª	boolean	false	false	A boolean indicating whether this IntersectionObserver will track changes in a targetâ€™s visibility.
delay ğŸ§ª	number	undefined	false	A number indicating the minimum delay in milliseconds between notifications from this observer for a given target. This must be set to at least 100 if trackVisibility is true.
skip	boolean	false	false	Skip creating the IntersectionObserver. You can use this to enable and disable the observer as needed. If skip is set while inView, the current state will still be kept.
triggerOnce	boolean	false	false	Only trigger the observer once.
initialInView	boolean	false	false	Set the initial value of the inView boolean. This can be used if you expect the element to be in the viewport to start with, and you want to trigger something when it leaves.
InView Props
The <InView /> component also accepts the following props:

Name	Type	Default	Required	Description
as	string	'div'	false	Render the wrapping element as this element. Defaults to div.
children	({ref, inView, entry}) => React.ReactNode, ReactNode		true	Children expects a function that receives an object containing the inView boolean and a ref that should be assigned to the element root. Alternatively pass a plain child, to have the <InView /> deal with the wrapping element. You will also get the IntersectionObserverEntry as `entry, giving you more details.
onChange	(inView, entry) => void		false	Call this function whenever the in view state changes. It will receive the inView boolean, alongside the current IntersectionObserverEntry.
IntersectionObserver v2 ğŸ§ª
The new v2 implementation of IntersectionObserver extends the original API, so you can track if the element is covered by another element or has filters applied to it. Useful for blocking clickjacking attempts or tracking ad exposure.

To use it, you'll need to add the new trackVisibility and delay options. When you get the entry back, you can then monitor if isVisible is true.

const TrackVisible = () => {
  const { ref, entry } = useInView({ trackVisibility: true, delay: 100 });
  return <div ref={ref}>{entry?.isVisible}</div>;
};
This is still a very new addition, so check caniuse for current browser support. If trackVisibility has been set, and the current browser doesn't support it, a fallback has been added to always report isVisible as true.

It's not added to the TypeScript lib.d.ts file yet, so you will also have to extend the IntersectionObserverEntry with the isVisible boolean.

Recipes
The IntersectionObserver itself is just a simple but powerful tool. Here's a few ideas for how you can use it.

Lazy image load
Trigger animations
Track impressions (Google Analytics, Tag Manager, etc)
FAQ
How can I assign multiple refs to a component?
You can wrap multiple ref assignments in a single useCallback:

import React, { useRef } from 'react';
import { useInView } from 'react-intersection-observer';

function Component(props) {
  const ref = useRef();
  const [inViewRef, inView] = useInView();

  // Use `useCallback` so we don't recreate the function on each render - Could result in infinite loop
  const setRefs = useCallback(
    (node) => {
      // Ref's from useRef needs to have the node assigned to `current`
      ref.current = node;
      // Callback refs, like the one from `useInView`, is a function that takes the node as an argument
      inViewRef(node);
    },
    [inViewRef],
  );

  return <div ref={setRefs}>Shared ref is visible: {inView}</div>;
}
rootMargin isn't working as expected
When using rootMargin, the margin gets added to the current root - If your application is running inside a <iframe>, or you have defined a custom root this will not be the current viewport.

You can read more about this on these links:

Intersection Observer API
w3c/IntersectionObserver: IntersectionObserver rootMargin ignored within iframe
w3c/IntersectionObserver: Cannot track intersection with an iframe's viewport
w3c/Support iframe viewport tracking
Testing
In order to write meaningful tests, the IntersectionObserver needs to be mocked. If you are writing your tests in Jest, you can use the included test-utils.js. It mocks the IntersectionObserver, and includes a few methods to assist with faking the inView state. When setting the isIntersecting value you can pass either a boolean value or a threshold between 0 and 1.

test-utils.js
Import the methods from react-intersection-observer/test-utils.

mockAllIsIntersecting(isIntersecting:boolean | number)
Set isIntersecting on all current IntersectionObserver instances.

mockIsIntersecting(element:Element, isIntersecting:boolean | number)
Set isIntersecting for the IntersectionObserver of a specific element.

intersectionMockInstance(element:Element): IntersectionObserver
Call the intersectionMockInstance method with an element, to get the (mocked) IntersectionObserver instance. You can use this to spy on the observe and unobserve methods.

Test Example
import React from 'react';
import { screen, render } from 'react-testing-library';
import { useInView } from 'react-intersection-observer';
import { mockAllIsIntersecting } from 'react-intersection-observer/test-utils';

const HookComponent = ({ options }) => {
  const [ref, inView] = useInView(options);
  return <div ref={ref}>{inView.toString()}</div>;
};

test('should create a hook inView', () => {
  render(<HookComponent />);

  // This causes all (existing) IntersectionObservers to be set as intersecting
  mockAllIsIntersecting(true);
  screen.getByText('true');
});

test('should create a hook inView with threshold', () => {
  render(<HookComponent options={{ threshold: 0.3 }} />);

  mockAllIsIntersecting(0.1);
  screen.getByText('false');

  // Once the threshold has been passed, it will trigger inView.
  mockAllIsIntersecting(0.3);
  screen.getByText('true');
});
Intersection Observer
Intersection Observer is the API used to determine if an element is inside the viewport or not. Browser support is really good - With Safari adding support in 12.1, all major browsers now support Intersection Observers natively. Add the polyfill, so it doesn't break on older versions of iOS and IE11.

Polyfill
You can import the polyfill directly or use a service like polyfill.io to add it when needed.

yarn add intersection-observer
Then import it in your app:

import 'intersection-observer';
If you are using Webpack (or similar) you could use dynamic imports, to load the Polyfill only if needed. A basic implementation could look something like this:

/**
 * Do feature detection, to figure out which polyfills needs to be imported.
 **/
async function loadPolyfills() {
  if (typeof window.IntersectionObserver === 'undefined') {
    await import('intersection-observer');
  }
}
Low level API
You can access the observe method, that react-intersection-observer uses internally to create and destroy IntersectionObserver instances. This allows you to handle more advanced use cases, where you need full control over when and how observers are created.

import { observe } from 'react-intersection-observer';
const destroy = observe(element, callback, options);
Name	Type	Required	Description
element	Element	true	DOM element to observe
callback	ObserverInstanceCallback	true	The callback function that IntersectionObserver will call
options	IntersectionObserverInit	false	The options for the IntersectionObserver
The observe method returns an unobserve function, that you must call in order to destroy the observer again.

âš ï¸ You most likely won't need this, but it can be useful if you need to handle IntersectionObservers outside React, or need full control over how instances are created.

Keywords
reactcomponenthooksviewportintersectionobserverlazy loadinviewuseInViewuseIntersectionObserver